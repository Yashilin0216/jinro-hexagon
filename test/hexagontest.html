<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hex Grid Movement (Vue 3 + SVG)</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: #0b1020; color: #e6ebff; }
    .wrap { display: grid; grid-template-rows: auto 1fr auto; min-height: 100svh; }
    header { padding: 12px 16px; backdrop-filter: blur(6px); background: rgba(255,255,255,0.04); border-bottom: 1px solid rgba(255,255,255,0.08); }
    header h1 { font-size: 16px; margin: 0; letter-spacing: 0.2px; }
    .board { position: relative; overflow: hidden; }
    .hud { position: absolute; inset: 12px auto auto 12px; background: rgba(0,0,0,0.35); padding: 10px 12px; border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; font-size: 13px; }
    .legend { display: flex; gap: 10px; align-items: center; margin-top: 6px; }
    .chip { width: 12px; height: 12px; border-radius: 3px; display: inline-block; }
    .chip.tile { background: #3a4b7a; }
    .chip.hover { background: #5e7ce2; }
    .chip.active { background: #f6c85f; }
    footer { padding: 10px 14px; font-size: 12px; opacity: 0.85; }
    svg { width: 100%; height: 100%; touch-action: none; }
    .tile { cursor: pointer; transition: opacity 120ms ease; }
    .tile:hover { opacity: 0.9; }
    .tile-label { user-select: none; pointer-events: none; font-size: 10px; fill: #cfd8ff; opacity: 0.65; }
  </style>
</head>
<body>
  <div id="app" class="wrap">
    <header>
      <h1>Hex Grid Movement — Vue 3 + SVG（クリック & キーボード移動対応）</h1>
    </header>

    <div class="board" tabindex="0" @keydown="on_key" ref="board_ref">
      <div class="hud">
        <div>選択: q={{ selected.q }}, r={{ selected.r }}</div>
        <div>サイズ: {{ cfg.map_cols }} × {{ cfg.map_rows }} ／ タイル半径: {{ cfg.hex_size }}</div>
        <div style="margin-top:6px">キー: Q W E / A S D（六方向移動）、矢印キー＝スクロール</div>
        <div class="legend">
          <span class="chip tile"></span> タイル
          <span class="chip hover"></span> ホバー
          <span class="chip active"></span> 現在位置
        </div>
      </div>

      <!-- SVG board -->
      <svg :viewBox="view_box" @mousemove="on_mouse_move" @mouseleave="hover=null" @click="on_click">
        <defs>
          <radialGradient id="g-active" cx="50%" cy="45%" r="70%">
            <stop offset="0%" stop-color="#ffe8b2" stop-opacity="1" />
            <stop offset="100%" stop-color="#f6c85f" stop-opacity="1" />
          </radialGradient>
          <linearGradient id="g-tile" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="#3a4b7a" />
            <stop offset="100%" stop-color="#1e2a4e" />
          </linearGradient>
          <linearGradient id="g-hover" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="#7ea0ff" />
            <stop offset="100%" stop-color="#5e7ce2" />
          </linearGradient>
        </defs>

        <g :transform="`translate(${camera.x} ${camera.y})`">
          <!-- tiles -->
          <template v-for="row in grid">
            <template v-for="cell in row">
              <polygon
                class="tile"
                :key="`p-${cell.q}-${cell.r}`"
                :points="hex_points(cell.x, cell.y)"
                :fill="tile_fill(cell)"
                :stroke="is_selected(cell) ? '#ffe38a' : 'rgba(255,255,255,0.18)'"
                :stroke-width="is_selected(cell) ? 2 : 1"
                @mouseenter="hover = { q: cell.q, r: cell.r }"
              />
              <text :x="cell.x" :y="cell.y+3" text-anchor="middle" class="tile-label">{{ cell.q }},{{ cell.r }}</text>
            </template>
          </template>

          <!-- player marker -->
          <circle :cx="pos_px.x" :cy="pos_px.y" :r="cfg.hex_size*0.45" fill="url(#g-active)" stroke="#704d00" stroke-width="1" />
        </g>
      </svg>
    </div>

    <footer>
      クリックでそのマスへ移動。Q/W/E/A/S/D で隣接ヘクスへ移動。矢印キーでスクロール（カメラ移動）。
    </footer>
  </div>

  <!-- Vue 3 via CDN -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <!-- socket.io client (将来的な同期用。未使用なら削除可) -->
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" integrity="sha384-kctw6FnkYQnHn3pQfZq+zT9r2n7lL2o0qAH9wQFqD3l7WQ8SRZc4m1Hk9m4iI9Hf" crossorigin="anonymous"></script>

  <script>
  const { createApp, ref, reactive, computed, onMounted } = Vue;

  createApp({
    setup() {
      // ---- config ----
      const cfg = reactive({
        hex_size: 28,        // 六角形の半径（ピクセル）
        map_cols: 14,        // 横（q方向）
        map_rows: 12,        // 縦（r方向）
        margin: 24           // 余白
      });

      // カメラ（スクロール）位置
      const camera = reactive({ x: 0, y: 0 });

      // 選択中の軸座標（axial: q, r）
      const selected = reactive({ q: 0, r: 0 });

      // ホバー中のセル
      const hover = ref(null); // { q, r }

      // 盤面（axial -> pixel）
      const grid = computed(() => {
        const rows = [];
        for (let r = 0; r < cfg.map_rows; r++) {
          const row = [];
          for (let q = 0; q < cfg.map_cols; q++) {
            const px = axial_to_pixel(q, r, cfg.hex_size);
            row.push({ q, r, x: px.x + cfg.margin, y: px.y + cfg.margin });
          }
          rows.push(row);
        }
        return rows;
      });

      const view_box = computed(() => {
        // SVG viewBox を盤面サイズに合わせる
        const last = axial_to_pixel(cfg.map_cols - 1, cfg.map_rows - 1, cfg.hex_size);
        const w = last.x + cfg.hex_size * 2 + cfg.margin * 2;
        const h = last.y + cfg.hex_size * 2 + cfg.margin * 2;
        return `0 0 ${w} ${h}`;
      });

      // 現在位置のピクセル座標
      const pos_px = computed(() => {
        const p = axial_to_pixel(selected.q, selected.r, cfg.hex_size);
        return { x: p.x + cfg.margin + camera.x, y: p.y + cfg.margin + camera.y };
      });

      // ---- hex math (pointy-top axial) ----
      function axial_to_pixel(q, r, size) {
        // pointy-top: x = size * (sqrt(3) * q + sqrt(3)/2 * r)
        //             y = size * (3/2 * r)
        const s3 = Math.sqrt(3);
        const x = size * (s3 * q + (s3 / 2) * r);
        const y = size * (1.5 * r);
        return { x, y };
      }

      function hex_corners(cx, cy, size) {
        const pts = [];
        for (let i = 0; i < 6; i++) {
          const angle = Math.PI / 180 * (60 * i - 30); // pointy-top
          pts.push([cx + size * Math.cos(angle), cy + size * Math.sin(angle)]);
        }
        return pts;
      }

      function hex_points(cx, cy) {
        return hex_corners(cx, cy, cfg.hex_size).map(p => p.join(',')).join(' ');
      }

      // 近傍（q,r）方向ベクトル（pointy-top axial）
      const dirs = [
        { q: +1, r: 0 },  // E (E)
        { q: +1, r: -1 }, // NE (W)
        { q: 0,  r: -1 }, // NW (Q)
        { q: -1, r: 0 },  // W (A)
        { q: -1, r: +1 }, // SW (S)
        { q: 0,  r: +1 }, // SE (D)
      ];

      function move_dir(i) {
        const nq = clamp(selected.q + dirs[i].q, 0, cfg.map_cols - 1);
        const nr = clamp(selected.r + dirs[i].r, 0, cfg.map_rows - 1);
        selected.q = nq; selected.r = nr;
      }

      function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

      function is_selected(cell) {
        return cell.q === selected.q && cell.r === selected.r;
      }

      function is_hover(cell) {
        return hover.value && hover.value.q === cell.q && hover.value.r === cell.r;
      }

      function tile_fill(cell) {
        if (is_selected(cell)) return 'url(#g-active)';
        if (is_hover(cell)) return 'url(#g-hover)';
        return 'url(#g-tile)';
      }

      // ---- input handlers ----
      const board_ref = ref(null);

      function on_key(e) {
        // 矢印キー：カメラ移動
        if (e.key.startsWith('Arrow')) {
          const step = 24;
          if (e.key === 'ArrowLeft') camera.x += step;
          if (e.key === 'ArrowRight') camera.x -= step;
          if (e.key === 'ArrowUp') camera.y += step;
          if (e.key === 'ArrowDown') camera.y -= step;
          e.preventDefault();
          return;
        }
        // 六方向移動（QWE / ASD）
        const k = e.key.toLowerCase();
        if (k === 'e') move_dir(1);
        else if (k === 'w') move_dir(2);
        else if (k === 'q') move_dir(2); // QとWどちらも北西寄りに割り当て（好みで調整可）
        else if (k === 'a') move_dir(3);
        else if (k === 's') move_dir(4);
        else if (k === 'd') move_dir(5);
      }

      function on_mouse_move(evt) {
        const pt = svg_point(evt);
        const ar = pixel_to_axial_rough(pt.x - camera.x - cfg.margin, pt.y - camera.y - cfg.margin, cfg.hex_size);
        hover.value = in_bounds(ar.q, ar.r) ? ar : null;
      }

      function on_click(evt) {
        const pt = svg_point(evt);
        const ar = pixel_to_axial_round(pt.x - camera.x - cfg.margin, pt.y - camera.y - cfg.margin, cfg.hex_size);
        if (in_bounds(ar.q, ar.r)) { selected.q = ar.q; selected.r = ar.r; }
      }

      function in_bounds(q, r) {
        return q >= 0 && q < cfg.map_cols && r >= 0 && r < cfg.map_rows;
      }

      // SVG座標を取得
      function svg_point(evt) {
        const svg = evt.currentTarget;
        const pt = svg.createSVGPoint();
        pt.x = evt.clientX; pt.y = evt.clientY;
        const inv = svg.getScreenCTM().inverse();
        const sp = pt.matrixTransform(inv);
        return { x: sp.x, y: sp.y };
      }

      // 軽量な近似（hover用）
      function pixel_to_axial_rough(x, y, size) {
        const s3 = Math.sqrt(3);
        const qf = (s3/3 * x - 1/3 * y) / size;
        const rf = (2/3 * y) / size;
        const { q, r } = axial_round(qf, rf);
        return { q, r };
      }

      // 厳密な丸め（click用）
      function pixel_to_axial_round(x, y, size) {
        const s3 = Math.sqrt(3);
        const qf = (s3/3 * x - 1/3 * y) / size;
        const rf = (2/3 * y) / size;
        return axial_round(qf, rf);
      }

      function axial_round(qf, rf) {
        // axial -> cube -> round -> axial
        const xf = qf;
        const zf = rf;
        const yf = -xf - zf;

        let rx = Math.round(xf);
        let ry = Math.round(yf);
        let rz = Math.round(zf);

        const x_diff = Math.abs(rx - xf);
        const y_diff = Math.abs(ry - yf);
        const z_diff = Math.abs(rz - zf);

        if (x_diff > y_diff && x_diff > z_diff) {
          rx = -ry - rz;
        } else if (y_diff > z_diff) {
          ry = -rx - rz;
        } else {
          rz = -rx - ry;
        }
        return { q: rx, r: rz };
      }

      // 初期フォーカス
      onMounted(() => {
        board_ref.value && board_ref.value.focus();
      });

      // ---- socket.io（任意：将来の同期用の雛形） ----
      // const socket = io("/", { transports: ["websocket"] });
      // socket.on("connect", () => {
      //   console.log("socket connected", socket.id);
      // });
      // function broadcast_move() {
      //   socket.emit("move", { q: selected.q, r: selected.r });
      // }
      // // 受信例
      // socket.on("move", data => {
      //   if (in_bounds(data.q, data.r)) { selected.q = data.q; selected.r = data.r; }
      // });

      return { cfg, grid, selected, hover, camera, view_box, pos_px, hex_points, tile_fill, is_selected, on_key, on_mouse_move, on_click, board_ref };
    }
  }).mount('#app');
  </script>
</body>
</html>
